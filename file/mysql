MySQL优化：
1.查询优化：
  a. 避免 SELECT *，需要什么数据，就查询对应的字段
  b.小表驱动大表，即小的数据集驱动大的数据集
      exist 适合子查询中表数据大于外查询表中数据的业务场景
	  in    适合子查询中表数据小于外部表数据的业务场景
  c.使用连接代替子查询，因为使用 join，MySQL 不会在内存中创建临时表
  d.适当添加冗余字段，减少表关联
  e.合理使用索引
2.索引使用
  a.单表查询：哪个列作查询条件，就在该列创建索引
  b.多表查询：left join 时，索引添加到右表关联字段；right join 时，索引添加到左表关联字段
  c.不要对索引列进行任何操作（计算、函数、类型转换）
  d.索引列中不要使用 !=，<> 非等于
  e.索引列不要为空，且不要使用 is null 或 is not null 判断
  f.索引字段是字符串类型，查询条件的值要加''单引号,避免底层类型自动转换

MySQL索引失效原因：
1.where条件出来的数据量大于总数据量的15%
2.对索引列进行了运算(+ - * / !)、函数操作或隐式类型转换
3.使用 <> 、not in 、not exist、!=
4.使用like "%_"
5.联合索引未匹配到第一个索引列

Join的执行顺序：
1.执行FROM子句对两张表进行笛卡尔积操作，生成虚拟表vt1
2.执行ON子句过滤掉vt1中不满足条件的行，生成虚拟表vt2
3.JOIN 添加外部行，LEFT JOIN会将左表未出现在vt2的行插入进vt2，每一行的剩余字段将被填充为NULL，RIGHT JOIN同理
4.WHERE条件过滤
5.SELECT

MySQL语句执行过程：
1.查询语句
  权限校验 -> 查询缓存 -> 分析器 —> 优化器 —> 执行器 —> 引擎
2.更新语句
  权限校验 -> 分析器 -> 优化器 -> 执行器 -> 引擎 -> redo log prepare -> binlog -> redo log commit
                                                 -> 缓存池 -> undo log

MyISAM与InnoDB的区别：
1.InnoDB支持事务，MyISAM不支持
2.InnoDB支持外键，而MyISAM不支持
3.MyISAM中索引和数据分离的(索引存B+树)，InnoDB中索引和数据都在B+树中
4.InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁