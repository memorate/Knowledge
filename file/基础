红黑树：
1.每个节点或者是黑色，或者是红色。
2.根节点是黑色。
3.每个叶子节点是黑色。
4.如果一个节点是红色的，则它的子节点必须是黑色的
5.从任意一个节点到叶子节点，经过的黑色节点是一样的。

HaspMap的put流程：
1.table尚未初始化，进行初始化
2.table已经初始化，且通过hash算法找到下标所在的位置数据为空,直接将数据存放到指定位置
3.下标所在位置不为空，且hash和key的值都相等，用新值替换旧值
4.下标所在位置不为空，链表是红黑树，进行红黑树的插入操作
5.下标所在位置不为空，是链表，将数据插在链表尾部，并检查需不需要树化（链表长度大于8，数组长度大于64）
6.插入完成后size加一并检查是否需要进行扩容

HashMap中的取模运算（确定下标）：
当 lenth = 2的n次幂时，hash % length = hash & (length - 1)
与运算比取模运算快

ConcurrentHaspMap线程安全的原理：
1.
2.
3.

ConcurrentHaspMap的put流程：
1.计算key的hash值
2.如果当前table还没有初始化先调用initTable方法将tab进行初始化
3.tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可
4.当前正在扩容，帮忙扩容
5.synchronize锁住当前node
6.当前为链表，在链表中插入新的键值对
7.当前为红黑树，将新的键值对插入到红黑树中
8.插入完键值对后再根据实际大小看是否需要转换成红黑树
9.对当前容量大小进行检查，如果超过了临界值就需要扩容

解决hash冲突的办法：
1.开放地址法，当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止
2.rehash，当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时
3.拉链法
4.建立公共溢出区，将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表

基本数据类型及大小：
byte     boolen    1字节      1字节 = 8位
char     short     2字节
int      float     4字节
long     double    8字节
