一、MyISAM与InnoDB的区别：
1.InnoDB支持事务，MyISAM不支持
2.InnoDB支持外键，而MyISAM不支持
3.MyISAM中索引和数据是分离的(索引存B+树)，InnoDB中索引和数据都在B+树中
4.InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁

二、MySQL优化：
1.查询优化：
  a. 避免 SELECT *，需要什么数据，就查询对应的字段
  b.小表驱动大表，即小的数据集驱动大的数据集
      exist 适合子查询中表数据大于外查询表中数据的业务场景
	  in    适合子查询中表数据小于外部表数据的业务场景
  c.使用连接代替子查询，因为使用 join，MySQL 不会在内存中创建临时表
  d.适当添加冗余字段，减少表关联
  e.合理使用索引
2.索引使用
  a.单表查询：哪个列作查询条件，就在该列创建索引
  b.多表查询：left join 时，索引添加到右表关联字段；right join 时，索引添加到左表关联字段
  c.不要对索引列进行任何操作（计算、函数、类型转换）
  d.索引列中不要使用 !=，<> 非等于
  e.索引列不要为空，且不要使用 is null 或 is not null 判断
  f.索引字段是字符串类型，查询条件的值要加''单引号,避免底层类型自动转换

三、MySQL索引失效原因：
1.where条件出来的数据量大于总数据量的15%
2.对索引列进行了运算(+ - * / !)、函数操作或隐式类型转换
3.使用 <> 、not in 、not exist、!=
4.使用like "%_"
5.联合索引未匹配到第一个索引列

四、Join的执行顺序：
1.执行 FROM 子句对两张表进行笛卡尔积操作，生成虚拟表 vt1
2.执行 ON 子句过滤掉 vt1 中不满足条件的行，生成虚拟表 vt2
3.JOIN 添加外部行，LEFT JOIN 会将左表未出现在 vt2 的行插入进 vt2，每一行的剩余字段将被填充为 NULL，RIGHT JOIN同理
4.WHERE 条件过滤
5.SELECT 选择需要的列

五、MySQL语句执行过程：
1.查询语句
  连接器 -> 查询缓存 -> 分析器 —> 优化器 —> 执行器 —> 引擎
2.更新语句(insert、update、delete)
  连接器 -> 查询缓存(删除该表所有缓存) -> 分析器 -> 优化器 -> 执行器 -> 引擎
  (引擎中流程：undo log -> redo log prepare -> binlog -> redo log commit)

六、SQL关键字执行顺序(共9个):
from -> on -> join -> where -> group by -> having + 聚合函数 -> select -> order by -> limit

七、Bin log、Redo、Undo log:
1.Bin log: 对数据操作进行备份，记录操作语句对具体行的操作以及操作前的整行信息或 sql 语句;
   a.基于语句的复制(STATEMENT): 将修改数据的 sql 语句记录到 bin log 中(数据量小，使用函数时会出现主从不一致问题，如sleep()函数， last_insert_id())
   b.基于行数据的复制(ROW): 将数据变化的信息写入 bin log 中(数据量大，但是不会出现主从不一致问题)
   c.混合复制(MIXED): 以上两种的结合体，默认使用语句复制，出问题时切换为行复制
2.Redo log: 记录暂不更新到磁盘的操作，延迟落盘，提高效率，记录数据页修改逻辑以及 change buffer 的变更;
3.Undo log: 用于事务回滚、保证事务隔离级别(read committed、repeatable read)，记录行记录变化前的数据;
4.区别:
  a.redo 与 undo 是存储引擎层的日志，只能用于 innodb；bin log 是 Sever 层日志，可以用于任何引擎;
  b.redo log 大小有限，超过阈值后会循环写；undo 与 bin log 不会;

八、MySQL主从同步:
1.master 将数据变化记录到 bin log 中;
2.slave 的 I/O thread 将 master 的 bin log events 保存到自己的 relay log 中;
3.slave 的 sql thread 检查 relay log，并更新数据;
PS: 此过程是异步的

九、MVCC:
1.定义: Multi-Version Concurrency Control，多版本并发控制。
       指的是使用 READ COMMITTED 和 REPEATABLE READ 两种隔离级别的事务在执行普通的 SELECT 操作时访问记录的版本链的过程。
       (版本链: Undo log 中对某行记录的修改形成的链表)
2.核心: 生成 ReadView 的时机不同。
    a.READ COMMITTED —— 每次读取数据前都生成一个 ReadView;
    b.REPEATABLE READ —— 在第一次读取数据时生成一个 ReadView;
3.ReadView:
    a.m_ids: 生成 ReadView 时当前系统中活跃的读写事务的事务id列表;
    b.min_trx_id: 生成 ReadView 时当前系统中活跃的读写事务中最小的事务id，也就是 m_ids 中的最小值;
    c.max_trx_id: 生成 ReadView 时系统中应该分配给下一个事务的id值;
    d.creator_trx_id: 生成该 ReadView 的事务的事务id;
4.判断步骤:
    a.被访问版本 trx_id == ReadView 中 creator_trx_id，可以访问
    b.被访问版本 trx_id < ReadView 中 min_trx_id，不可以访问
    c.被访问版本 trx_id > ReadView 中 max_trx_id，不可以访问
    d.min_trx_id < trx_id < max_trx_id 并且 trx_id 在 m_ids 中，不可以访问